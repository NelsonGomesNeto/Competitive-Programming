#include <bits/stdc++.h>
#define DEBUG if(0)
#define lli long long int
#define ldouble long double
using namespace std;

const int maxN = 1e3; int n, m, x, y;
int a[maxN][maxN];
lli acc[maxN + 1][maxN + 1];

lli getSum(int loi, int loj, int hii, int hij)
{
  return acc[hii + 1][hij + 1] - acc[hii + 1][loj] - acc[loi][hij + 1] + acc[loi][loj];
}

struct Rect
{
  int loi, loj, hii, hij;
  lli value()
  {
    return getSum(loi, loj, hii, hij);
  }
};
int byLoI(const Rect &a, const Rect &b)
{
  return a.loi < b.loi;
}
int byHiI(const Rect &a, const Rect &b)
{
  return a.hii < b.hii;
}
int byLoJ(const Rect &a, const Rect &b)
{
  return a.loj < b.loj;
}
int byHiJ(const Rect &a, const Rect &b)
{
  return a.hij < b.hij;
}
vector<Rect> loirects, lojrects;
vector<Rect> hiirects, hijrects;
vector<lli> accloi, accloj;
vector<lli> acchii, acchij;

int binarySearchI(vector<Rect> &arr, int target, bool upperBound)
{
  int lo = 0, hi = arr.size() - 1;
  while (lo < hi)
  {
    int mid = (lo + hi + upperBound) >> 1;
    if (upperBound)
    {
      if (arr[mid].hii <= target) lo = mid;
      else hi = mid - 1;
    }
    else
    {
      if (arr[mid].loi >= target) hi = mid;
      else lo = mid + 1;
    }
  }
  if (upperBound) return arr[lo].hii <= target ? lo : -1;
  else return arr[lo].loi >= target ? lo : (int)arr.size();
}
int binarySearchJ(vector<Rect> &arr, int target, bool upperBound)
{
    int lo = 0, hi = arr.size() - 1;
  while (lo < hi)
  {
    int mid = (lo + hi + upperBound) >> 1;
    if (upperBound)
    {
      if (arr[mid].hij <= target) lo = mid;
      else hi = mid - 1;
    }
    else
    {
      if (arr[mid].loj >= target) hi = mid;
      else lo = mid + 1;
    }
  }
  if (upperBound) return arr[lo].hij <= target ? lo : -1;
  else return arr[lo].loj >= target ? lo : (int)arr.size();
}

int main()
{
  while (~scanf("%d %d", &n, &m))
  {
    scanf("%d %d", &x, &y);

    for (int i = 0; i < n; i++)
      for (int j = 0; j < m; j++)
        scanf("%d", &a[i][j]);

    for (int i = 0; i < n; i++)
      for (int j = 0; j < m; j++)
        acc[i + 1][j + 1] = acc[i + 1][j] + acc[i][j + 1] - acc[i][j] + a[i][j];

    loirects.clear(), lojrects.clear();
    hiirects.clear(), hijrects.clear();
    for (int hehe = 0; hehe < 2; hehe++)
    {
      for (int i = 0; i + x - 1 < n; i++)
        for (int j = 0; j + y - 1 < m; j++)
        {
          Rect curr = Rect{i, j, i + x - 1, j + y - 1};
          loirects.push_back(curr);
          hiirects.push_back(curr);
          lojrects.push_back(curr);
          hijrects.push_back(curr);
        }
      swap(x, y);
    }
    sort(loirects.begin(), loirects.end(), byLoI);
    sort(lojrects.begin(), lojrects.end(), byLoJ);
    sort(hiirects.begin(), hiirects.end(), byHiI);
    sort(hijrects.begin(), hijrects.end(), byHiJ);

    accloi.clear();
    accloi.resize(loirects.size() + 1, 0);
    accloj.clear();
    accloj.resize(lojrects.size() + 1, 0);
    acchii.clear();
    acchii.resize(hiirects.size() + 1, 0);
    acchij.clear();
    acchij.resize(hijrects.size() + 1, 0);

    for (int i = loirects.size() - 1; i >= 0; i--)
      accloi[i] = max(accloi[i + 1], loirects[i].value());
    for (int i = lojrects.size() - 1; i >= 0; i--)
      accloj[i] = max(accloj[i + 1], lojrects[i].value());
    for (int i = 0; i < hiirects.size(); i++)
      acchii[i + 1] = max(acchii[i], hiirects[i].value());
    for (int i = 0; i < hijrects.size(); i++)
      acchij[i + 1] = max(acchij[i], hijrects[i].value());

    lli ans = 0;
    for (Rect &r: loirects)
    {
      ans = max(ans, r.value());

      DEBUG printf("%d %d %d %d - %lld\n", r.loi, r.loj, r.hii, r.hij, r.value());
      int after = binarySearchI(loirects, r.hii + 1, false);
      if (after < loirects.size())
        ans = max(ans, r.value() + accloi[after]);
      // for (int j = after; j < loirects.size(); j++)
      // {
      //   assert(r.hii < loirects[j].loi);
      //   ans = max(ans, r.value() + loirects[j].value());
      // }
      int before = binarySearchI(hiirects, r.loi - 1, true);
      if (before >= 0)
        ans = max(ans, r.value() + acchii[before + 1]);
      // for (int j = 0; j < before; j++)
      // {
      //   assert(hiirects[j].hii < r.loi);
      //   ans = max(ans, r.value() + hiirects[j].value());
      // }

      after = binarySearchJ(lojrects, r.hij + 1, false);
      if (after < lojrects.size())
        ans = max(ans, r.value() + accloj[after]);
      // for (int j = after; j < lojrects.size(); j++)
      // {
      //   assert(r.hij < lojrects[j].loj);
      //   ans = max(ans, r.value() + lojrects[j].value());
      // }
      before = binarySearchJ(hijrects, r.loj - 1, true);
      if (before >= 0)
        ans = max(ans, r.value() + acchij[before + 1]);
      // for (int j = 0; j < before; j++)
      // {
      //   assert(hijrects[j].hij < r.loj);
      //   ans = max(ans, r.value() + hijrects[j].value());
      // }
    }
    printf("%lld\n", ans);
  }
  return 0;
}